#!/usr/bin/env bash

set -euxo pipefail

# Install PostgreSQL if not installed
if ! dpkg -l | grep -q postgresql; then
  sudo apt-get install -y postgresql postgresql-contrib
fi

# Check if PostgreSQL service is running
if ! systemctl is-active --quiet postgresql; then
  sudo systemctl start postgresql
fi

# Create user and database if they don't exist
if ! sudo -u postgres psql -tAc "SELECT 1 FROM pg_roles WHERE rolname='satoshi'" | grep -q 1; then
  sudo -u postgres psql -c "CREATE USER satoshi WITH PASSWORD 'nakamoto' SUPERUSER;"
fi

if ! sudo -u postgres psql -tAc "SELECT 1 FROM pg_database WHERE datname='ckpool'" | grep -q 1; then
  sudo -u postgres psql -c "CREATE DATABASE ckpool OWNER satoshi;"
fi

# Modify pg_hba.conf to use md5 authentication for local connections
PG_HBA_PATH=$(sudo -u postgres psql -t -c "SHOW hba_file;" | xargs)

# Backup the original file
if [ ! -f "${PG_HBA_PATH}.bak" ]; then
    sudo cp $PG_HBA_PATH ${PG_HBA_PATH}.bak
    echo "Backup created: ${PG_HBA_PATH}.bak"
else
    echo "Backup already exists, skipping backup creation"
fi

# Update the authentication method for local connections
sudo sed -i '/^local.*all.*all.*peer/c\local all all md5' $PG_HBA_PATH
sudo sed -i '/^host.*all.*all.*127.0.0.1\/32/c\host all all 127.0.0.1/32 md5' $PG_HBA_PATH

# Reload PostgreSQL to apply changes
sudo systemctl reload postgresql

# Create table if it doesn't exist (now using -h localhost to force TCP connection)
PGPASSWORD="nakamoto" psql -h localhost -U satoshi -d ckpool -c "
  CREATE TABLE IF NOT EXISTS shares (
      id SERIAL PRIMARY KEY,
      blockheight INTEGER,
      workinfoid BIGINT,
      clientid BIGINT,
      enonce1 TEXT,
      nonce2 TEXT,
      nonce TEXT,
      ntime TEXT,
      diff DOUBLE PRECISION,
      sdiff DOUBLE PRECISION,
      hash TEXT,
      result BOOLEAN,
      reject_reason TEXT,
      error TEXT,
      errn INTEGER,
      createdate TEXT,
      createby TEXT,
      createcode TEXT,
      createinet TEXT,
      workername TEXT,
      username TEXT,
      lnurl TEXT,
      address TEXT,
      agent TEXT
  )
  "

# This is wildly unacceptable and demonstrates why we made need to move to an internal query-library model
PGPASSWORD="nakamoto" psql -h localhost -U satoshi -d ckpool -c "
  CREATE OR REPLACE FUNCTION compress_shares(
      window_start_val BIGINT,
      window_end_val BIGINT
  ) RETURNS TABLE(id BIGINT, total_diff NUMERIC, workername TEXT) LANGUAGE plpgsql AS $$
  DECLARE initial_results TEXT;
          final_results TEXT;
  BEGIN
      -- calculate initial state for sanity check
      WITH initial_data AS (
          SELECT
              MIN(shares.id)::BIGINT as min_id,
              COALESCE(SUM(shares.diff), 0)::NUMERIC as total_diff,
              COALESCE(shares.workername, '') as workername
          FROM shares
          WHERE shares.id > window_start_val AND shares.id <= window_end_val AND shares.result = true
          GROUP BY shares.workername
      )
      SELECT string_agg(
                     initial_data.min_id::text || '|' || initial_data.total_diff::text || '|' || initial_data.workername,
                     ','
                     ORDER BY min_id
             )
      INTO initial_results
      FROM initial_data;

      -- fix records with broken or 0 values for blockheight
      UPDATE shares
      SET blockheight = subq.fill_value
      FROM (
               SELECT
                   s.id,
                   MAX(CASE WHEN s.blockheight > 0 THEN s.blockheight END)
                   OVER (
                       ORDER BY s.id
                       ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                       ) as fill_value
               FROM shares s
               WHERE s.id > window_start_val AND s.id <= window_end_val
           ) subq
      WHERE shares.id > window_start_val AND shares.id <= window_end_val AND
          shares.id = subq.id AND
          shares.blockheight = 0 AND
          subq.fill_value IS NOT NULL;

      -- update share values by setting all except the first to 0 and the first to the sum of the others
      UPDATE shares
      SET diff = subq.total_diff
      FROM (
               SELECT
                   s.workername,
                   s.blockheight,
                   MIN(s.id) as keep_id,
                   SUM(s.diff) as total_diff
               FROM shares s
               WHERE s.id > window_start_val AND s.id <= window_end_val AND s.blockheight > 0 AND s.result = true
               GROUP BY s.workername, s.blockheight
           ) subq
      WHERE shares.id > window_start_val AND shares.id <= window_end_val
        AND shares.id = subq.keep_id;

      -- remove the shares with diff 0
      DELETE FROM shares
      WHERE shares.id > window_start_val AND shares.id <= window_end_val AND
          shares.id NOT IN (
              SELECT MIN(s.id)
              FROM shares s
              WHERE s.id > window_start_val AND s.id <= window_end_val AND s.blockheight > 0 AND s.result = true
              GROUP BY s.workername, s.blockheight
          ) AND
          shares.blockheight > 0;

      -- calculate final output values for sanity check
      WITH final_data AS (
          SELECT
              MIN(shares.id) as min_id,
              COALESCE(SUM(shares.diff), 0) as total_diff,
              COALESCE(shares.workername, '') as workername
          FROM shares
          WHERE shares.id > window_start_val AND shares.id <= window_end_val AND shares.result = true
          GROUP BY shares.workername
      )
      SELECT string_agg(
                     final_data.min_id::text || '|' || final_data.total_diff::text || '|' || final_data.workername,
                     ','
                     ORDER BY min_id
             )
      INTO final_results
      FROM final_data;

      -- reject the unexpected case that a workername is now seeing a different total number of shares O_O
      IF initial_results != final_results THEN
          RAISE EXCEPTION 'Data integrity check failed for window % to %: grouped results changed during processing. Initial: %, Final: %',
              window_start_val, window_end_val, initial_results, final_results;
      END IF;

      -- return aggregate data for safety check
      RETURN QUERY
          SELECT
              MIN(shares.id)::BIGINT as id,
              SUM(shares.diff)::NUMERIC as total_diff,
              shares.workername
          FROM shares
          WHERE shares.id > window_start_val AND shares.id <= window_end_val AND shares.result = true
          GROUP BY shares.workername
          ORDER BY MIN(shares.id);
  END $$;
  "

PGPASSWORD="nakamoto" psql -h localhost -U satoshi -d ckpool -c "
  CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      username VARCHAR(128) NOT NULL,
      btcaddress BOOLEAN DEFAULT FALSE,
      lightning_address VARCHAR(255),
      workername VARCHAR(255),
      script BOOLEAN,
      segwit BOOLEAN,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
      last_seen TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
      UNIQUE(username, lightning_address)
  )
  "

PGPASSWORD="nakamoto" psql -h localhost -U satoshi -d ckpool -c "
  CREATE TABLE IF NOT EXISTS blocks (
      id SERIAL PRIMARY KEY,
      blockheight INTEGER NOT NULL,
      blockhash VARCHAR(64) NOT NULL,
      confirmed BOOLEAN DEFAULT FALSE,
      workername VARCHAR(255),
      username VARCHAR(128),
      diff DOUBLE PRECISION,
      time_found TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
      coinbasevalue BIGINT,
      rewards_processed BOOLEAN DEFAULT FALSE
  )
  "
PGPASSWORD="nakamoto" psql -h localhost -U satoshi -d ckpool -c "
  INSERT INTO blocks (blockheight, blockhash, confirmed)
  SELECT 0, '0000000000000000000000000000000000000000000000000000000000000000', FALSE
  WHERE NOT EXISTS (SELECT 1 FROM blocks);
"

echo "PostgreSQL is running"
echo "Database: ckpool"
echo "User: satoshi"
echo "Password: nakamoto"
echo "Table: shares with columns (id, data, created_at)"
echo "Connection string: dbname=ckpool user=satoshi password=nakamoto host=localhost"
